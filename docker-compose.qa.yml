# ═══════════════════════════════════════════════════════════════
#  QA STACK — EXPERT UNIFIED VERSION
#  Uso: 
#    - Levantar todo: docker compose --env-file .env.qa -f docker-compose.qa.yml up -d
#    - Solo Sonar:     docker compose --profile sonar up -d
#    - Solo E2E:       docker compose --profile test-e2e up
# ═══════════════════════════════════════════════════════════════

x-common-healthcheck: &common-healthcheck
  interval: 15s
  timeout: 10s
  retries: 5
  start_period: 30s

networks:
  fuc-qa-network:
    name: fuc-qa-network
    driver: bridge

volumes:
  mongodb_qa_data:
    name: fuc-mongodb-qa-data
  sonarqube_data:
    name: fuc-sonarqube-data
  sonarqube_extensions:
    name: fuc-sonarqube-extensions
  sonarqube_logs:
    name: fuc-sonarqube-logs
  sonarqube_db_data:
    name: fuc-sonarqube-db-data
  sonar_scanner_cache:
    name: fuc-sonar-scanner-cache
  influxdb_data:
    name: fuc-influxdb-data
  grafana_data:
    name: fuc-grafana-data

services:

  # --- Base de datos — MongoDB (App) ---
  db:
    image: mongo:7
    container_name: fuc-mongodb-qa
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USER}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD}
      MONGO_INITDB_DATABASE: ${MONGO_DB}
    ports:
      - "${DB_PORT:-27017}:27017"
    volumes:
      - mongodb_qa_data:/data/db
    healthcheck:
      test: [ "CMD", "mongosh", "--eval", "db.adminCommand('ping')", "--quiet" ]
      <<: *common-healthcheck
    networks:
      - fuc-qa-network

  # --- Backend — Go API ---
  backend:
    build:
      context: ./fuc-sena
      dockerfile: Dockerfile
    container_name: fuc-api-qa
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
    environment:
      PORT: ${BACKEND_PORT:-8080}
      MONGO_URI: mongodb://${MONGO_USER}:${MONGO_PASSWORD}@db:27017/${MONGO_DB}?authSource=admin
      MONGO_USER: ${MONGO_USER}
      MONGO_PASSWORD: ${MONGO_PASSWORD}
      MONGO_DB: ${MONGO_DB}
    ports:
      - "${BACKEND_PORT:-8080}:8080"
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8080/health" ]
      <<: *common-healthcheck
    networks:
      - fuc-qa-network

  # --- Frontend — Next.js ---
  frontend:
    build:
      context: ./fuc-app-web
      dockerfile: Dockerfile
      target: ${FRONTEND_TARGET:-runtime}
    container_name: fuc-app-web-qa
    restart: unless-stopped
    depends_on:
      - backend
    ports:
      - "${FRONTEND_PORT:-3000}:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://backend:8080/api/v1
    networks:
      - fuc-qa-network

  # --- SonarQube — Database (Postgres) ---
  sonar-db:
    image: postgres:15-alpine
    container_name: fuc-sonar-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: sonar
      POSTGRES_PASSWORD: sonar
      POSTGRES_DB: sonarqube
    ports:
      - "15432:5432" # 15432 es el puerto interno de SonarQube
    volumes:
      - sonarqube_db_data:/var/lib/postgresql/data
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U sonar -d sonarqube" ]
      <<: *common-healthcheck
    networks:
      - fuc-qa-network

  # --- SonarQube — Server ---
  sonarqube:
    image: sonarqube:10.4-community
    container_name: fuc-sonarqube
    restart: unless-stopped
    depends_on:
      sonar-db:
        condition: service_healthy
    environment:
      SONAR_JDBC_URL: jdbc:postgresql://sonar-db:5432/sonarqube
      SONAR_JDBC_USERNAME: sonar
      SONAR_JDBC_PASSWORD: sonar
      SONAR_ES_BOOTSTRAP_CHECKS_DISABLE: "true"
    ports:
      - "9000:9000"
    volumes:
      - sonarqube_data:/opt/sonarqube/data
      - sonarqube_extensions:/opt/sonarqube/extensions
      - sonarqube_logs:/opt/sonarqube/logs
    healthcheck:
      test: [ "CMD-SHELL", "curl -sf http://localhost:9000/api/system/status | grep -q '\"status\":\"UP\"'" ]
      interval: 20s
      timeout: 10s
      retries: 15
      start_period: 120s
    networks:
      - fuc-qa-network

  # --- QA Runner (Master Orchestrator) ---
  qa-runner:
    build:
      context: ./qa
      dockerfile: Dockerfile.qa
    container_name: fuc-qa-runner
    profiles: [ "test-e2e", "all" ]
    depends_on:
      backend:
        condition: service_healthy
      frontend:
        condition: service_started
      sonarqube:
        condition: service_started
    environment:
      - ENVIRONMENT=${ENVIRONMENT:-qa}
      - BACKEND_URL=http://backend:8080
      - FRONTEND_URL=http://frontend:3000
      - SONAR_HOST_URL=http://sonarqube:9000
      - SONAR_TOKEN=${SONAR_TOKEN}
      - PROJECT_KEY=${PROJECT_KEY:-fuc-sena}
      - RUN_SONAR=${RUN_SONAR:-false}
      - SONAR_WAIT_SECONDS=${SONAR_WAIT_SECONDS:-120}
      - SONAR_SCAN_TIMEOUT=${SONAR_SCAN_TIMEOUT:-11m}
    ports:
      - "8181:8181"
    volumes:
      - ./qa/reports:/qa/reports
      # Montar config/tests para que el HTML refleje el último run (sin requerir rebuild)
      - ./qa/run-tests.sh:/qa/run-tests.sh:ro
      - ./qa/api:/qa/api:ro
      - ./qa/playwright.config.ts:/qa/playwright.config.ts:ro
      - ./qa/ui/tests:/qa/ui/tests:ro
      - ./qa/performance:/qa/performance:ro
      - sonar_scanner_cache:/root/.sonar/cache
      - ./fuc-sena:/src/backend:ro
      - ./fuc-app-web:/src/frontend:ro
    command: [ "bash", "run-tests.sh" ]
    networks:
      - fuc-qa-network

  # --- InfluxDB (time-series store para métricas k6) ---
  influxdb:
    image: influxdb:1.8
    container_name: fuc-influxdb
    profiles: [ "perf" ]
    environment:
      INFLUXDB_DB: k6
      INFLUXDB_HTTP_AUTH_ENABLED: "false"
    ports:
      - "8086:8086"
    volumes:
      - influxdb_data:/var/lib/influxdb
    networks:
      - fuc-qa-network

  # --- Grafana (dashboard de métricas k6) ---
  grafana:
    image: grafana/grafana:latest
    container_name: fuc-grafana
    profiles: [ "perf" ]
    depends_on:
      - influxdb
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: admin
      GF_AUTH_ANONYMOUS_ENABLED: "true"
      GF_AUTH_ANONYMOUS_ORG_ROLE: Viewer
      GF_DASHBOARDS_DEFAULT_HOME_DASHBOARD_PATH: /var/lib/grafana/dashboards/k6.json
    ports:
      - "3001:3000"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./qa/grafana/provisioning:/etc/grafana/provisioning:ro
      - ./qa/grafana/dashboards:/var/lib/grafana/dashboards:ro
    networks:
      - fuc-qa-network

  # --- k6 Runner (solo performance) ---
  k6-runner:
    build:
      context: ./qa
      dockerfile: Dockerfile.qa
    container_name: fuc-k6-runner
    profiles: [ "perf" ]
    depends_on:
      backend:
        condition: service_healthy
      influxdb:
        condition: service_started
    environment:
      - BACKEND_URL=http://backend:8080
    volumes:
      - ./qa/reports:/qa/reports
      - ./qa/performance:/qa/performance:ro
    command: [ "bash", "-lc", "mkdir -p /qa/reports/k6 && k6 run /qa/performance/k6-tests.js -e BACKEND_URL=$$BACKEND_URL --out influxdb=http://influxdb:8086/k6 --summary-export /qa/reports/k6/summary.json" ]
    networks:
      - fuc-qa-network

  # --- Allure Reports Viewer ---
  allure:
    # Pinned version to match allure-docker-service-ui compatibility.
    # (UI image is old; some newer API versions can trigger "Network Error" in the UI.)
    image: frankescobar/allure-docker-service:2.13.6
    container_name: fuc-allure
    profiles: [ "test-e2e", "all" ]
    environment:
      CHECK_RESULTS_EVERY_SECONDS: 1
      KEEP_HISTORY: 1
    ports:
      - "5050:5050"
    volumes:
      - ./qa/reports/allure-results:/app/allure-results
      - ./qa/reports/allure-reports:/app/default-reports
    networks:
      - fuc-qa-network

  # --- Allure UI (React SPA; sin puerto expuesto — nginx hace de proxy) ---
  allure-ui:
    image: frankescobar/allure-docker-service-ui
    container_name: fuc-allure-ui
    profiles: [ "test-e2e", "all" ]
    depends_on:
      - allure
    environment:
      # Nginx expone el puerto 5252 en el host; ambos servicios quedan bajo el mismo origen
      # y el navegador no levanta error de CORS.
      - ALLURE_DOCKER_PUBLIC_API_URL=http://localhost:5252
      - ALLURE_DOCKER_PUBLIC_API_URL_PREFIX=
    networks:
      - fuc-qa-network

  # --- Nginx reverse-proxy: une UI y API bajo localhost:5252 (mismo origen) ---
  allure-nginx:
    image: nginx:alpine
    container_name: fuc-allure-nginx
    profiles: [ "test-e2e", "all" ]
    depends_on:
      - allure
      - allure-ui
    ports:
      - "5252:80"
    volumes:
      - ./qa/allure-nginx.conf:/etc/nginx/nginx.conf:ro
    networks:
      - fuc-qa-network
